<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>D3.js Contour Plot Example</title>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://d3js.org/d3-contour.v1.min.js"></script>
  </head>
  <body>
    <h1>D3.js Contour Plot Example</h1>

    <label for="dataset_selector">select a dataset</label>
    <select name="dataset" id="dataset_selector" onchange="updateDataset()">
      <option value="iris/petal length (cm)_vs_petal width (cm).txt" selected>
        iris/petal length (cm)_vs_petal width (cm)
      </option>
      <option value="iris/sepal length (cm)_vs_petal length (cm).txt">
        iris/sepal length (cm)_vs_petal length (cm)
      </option>
    </select>

    <div id="chart"></div>
    <div id="scatter"></div>

    <script>
      // returns the alpha part of a hex code given the tranparency
      function hexAlpha(transparency) {
        return Math.round((transparency * 255) / 100)
          .toString(16)
          .padStart(2, "0");
      }

      // returns a hex code representing red and transparance regarding probability
      function prob(propability) {
        return "#FF0000" + hexAlpha(100.0 * propability);
      }

      // set the dimensions and margins of the graph
      var margin = { top: 20, right: 30, bottom: 30, left: 40 };

      // size of the plot
      var size = {
        x: 500 - margin.left - margin.right,
        y: 500 - margin.top - margin.bottom,
      };

      // Scatter Plot
      var scatter_svg = d3
        .select("#scatter")
        .append("svg")
        .attr("width", size.x + margin.left + margin.right)
        .attr("height", size.y + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // append the svg object to the body of the page
      var contour_svg = d3
        .select("#chart")
        .append("svg")
        .attr("width", size.x + margin.left + margin.right)
        .attr("height", size.y + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      function render_graph(fname) {
        // read data
        // var fileNames = ['grid_1d.txt', 'sub_grid_prob_0.txt', 'sub_grid_prob_1.txt',
        // 'sub_grid_prob_2.txt', 'sub_grid_prob_3.txt', 'sub_grid_prob_4.txt', 'sub_grid_prob_5.txt',
        // 'sub_grid_prob_6.txt', 'sub_grid_prob_7.txt', 'sub_grid_prob_8.txt', 'sub_grid_prob_9.txt'];
        var fileNames = [fname];
        var filePaths = fileNames.map((fileName) => "resources/" + fileName);

        var header = null

        const promises = filePaths.map((filePath) =>
          fetch(filePath)
            .then((response) => response.text())
            .then((data) => {
              let lines = data.trim().split("\n");
              header = lines.slice(0,1)
              lines = lines.slice(1).map((line) => line.split(",")); // slice(1) to skip the header
              lines = lines.map((line) => {
                return line.map((point) => parseFloat(point));
              });
              return lines;
            })
            .catch((error) =>
              console.error(`Error reading ${filePath}:`, error)
            )
        );

        Promise.all(promises).then((results) => {

          // we can log the header here, how to make it into a legend?
          // TODO: add legend
          console.log(header)

          // parse the array returned by the file reader
          // results has shape [ [Array(5),Array(5),...], [Array(5),Array(5),...], ] as it contains data from ALL parsed files

          // for now, only use one file (likely want to make this a function later):
          results = results[0];

          var grid_2d = results.map((line) => line.slice(0, 2));
          // console.log("grid_2d:");
          // console.log(grid_2d);

          var probabilities = [];
          for (i = 2; i < results[0].length; i++) {
            probabilities.push(results.map((line) => line[i]));
          }
          // console.log("probabilities:");
          // console.log(probabilities);

          // shape of sub_grid_prob before ravel()
          const shape_sub_grid_prob = {
            x: 100,
            y: 100,
          };

          const thresholds = 15;
          const bandwidth = 30;
          const extent_x = d3.extent(
            grid_2d.map(function (value, index) {
              return value[0];
            })
          );
          const extent_y = d3.extent(
            grid_2d.map(function (value, index) {
              return value[1];
            })
          );

          // Scaling functions
          const scale_x = d3
            .scaleLinear()
            .domain([extent_x[0], extent_x[1]])
            .range([0, size.x]);
          const scale_y = d3
            .scaleLinear()
            .domain([extent_y[0], extent_y[1]])
            .range([size.y, 0]);

          // remove ("reset") previous axes and contour lines
          // use this ">" selector to remove only everything "inside" the canvas (the child elements)
          document.querySelectorAll(" svg > g > * ").forEach((e) => e.remove());

          // Add X axis
          contour_svg
            .append("g")
            .attr("transform", "translate(0," + size.y + ")")
            .call(d3.axisBottom(scale_x));
          // Add Y axis
          contour_svg.append("g").call(d3.axisLeft(scale_y));

          // contours data generation
          var colorList = ["steelblue", "red", "lightgreen"];
          for (j = 0; j < probabilities.length; j++) {
            let contours = d3
              .contourDensity()
              .x((d) => scale_x(d[0]))
              .y((d) => scale_y(d[1]))
              .weight(function (d, i) {
                return probabilities[j][i];
              })
              .bandwidth(bandwidth)
              .thresholds(thresholds)(grid_2d);

            const projection = d3
              .geoIdentity()
              .fitSize([size.x, size.y], contours[0]);
            const path = d3.geoPath().projection(projection);

            contour_svg
              .append("g")
              .attr("fill", "none")
              .attr("stroke", colorList[j])
              .attr("stroke-linejoin", "round")
              .selectAll("path")
              .data(contours)
              .enter()
              .append("path")
              .attr("stroke-width", 1)
              .attr("d", path);
          }

          // Scatter plot
          // Axis
          scatter_svg
            .append("g")
            .attr("transform", "translate(0," + size.y + ")")
            .call(d3.axisBottom(scale_x));

          scatter_svg.append("g").call(d3.axisLeft(scale_y));

          scatter_svg
            .selectAll("circle")
            .data(grid_2d)
            .enter()
            .append("circle")
            .attr("r", 1)
            .attr("fill", function (d, i) {
              return prob(probabilities[2][i]);
            })
            .attr("cx", function (d, i) {
              return scale_x(d[0]);
            })
            .attr("cy", function (d, i) {
              return scale_y(d[1]);
            });
        }); // end of promises
      }

      function updateDataset() {
        var e = document.getElementById("dataset_selector");
        render_graph(e.value);
      }

      updateDataset();
    </script>
  </body>
</html>
