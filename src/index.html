<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>D3.js Contour Plot Example</title>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://d3js.org/d3-contour.v1.min.js"></script>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <h1>D3.js Contour Plot Example</h1>

    <label for="dataset_selector">select a dataset</label>
    <select name="dataset" id="dataset_selector" onchange="updateDataset()">
      <option value="iris/petal length (cm)_vs_petal width (cm).txt" selected>
        iris/petal length (cm)_vs_petal width (cm)
      </option>
      <option value="iris/sepal length (cm)_vs_petal length (cm).txt">
        iris/sepal length (cm)_vs_petal length (cm)
      </option>
      <option value="iris/sepal length (cm)_vs_petal width (cm).txt">
        iris/sepal length (cm)_vs_petal width (cm)
      </option>
      <option value="iris/sepal length (cm)_vs_sepal width (cm).txt">
        iris/sepal length (cm)_vs_sepal width (cm)
      </option>
      <option value="iris/sepal width (cm)_vs_petal length (cm).txt">
        iris/sepal width (cm)_vs_petal length (cm)
      </option>
      <option value="iris/sepal width (cm)_vs_petal width (cm).txt">
        iris/sepal width (cm)_vs_petal width (cm)
      </option>
    </select>

    <div id="chart"></div>
    <div id="scatter"></div>

    <script>
/////////////////////////////////////////////////////////////////////////
// Helper functions /////////////////////////////////////////////////////

// Renders the whole graph with new dataset
function updateDataset() {
  var e = document.getElementById("dataset_selector");
  render_graph(e.value);
}

// Returns the alpha part of a hex code given the tranparency
function hexAlpha(transparency) {
  return Math.round((transparency * 255) / 100)
    .toString(16)
    .padStart(2, "0");
}

// Returns a hex code representing red and transparance regarding probability (probability between [0,1])
function prob(hexCode, propability) {
  return hexCode + hexAlpha(100.0 * propability);
}

// Sorts the given domElements by its values in ascending or descending order in place
function dom_sort(order, domElements) {
  if (order === "ascending") {
    console.log("sort dom elements in ascending order");
    domElements.sort((a, b) => {
      const probA = a.value;
      const probB = b.value;
      return probA - probB;
    });
  } else {
    console.log("sort dom elements in descending order");
    domElements.sort((a, b) => {
      const probA = a.value;
      const probB = b.value;
      return probB - probA;
    });
  }
}

/////////////////////////////////////////////////////////////////////////
// Prepare Canvas ///////////////////////////////////////////////////////

// set the dimensions and margins of the graph
var margin = {
  top: 20,
  right: 30,
  bottom: 30,
  left: 40
};

// size of the plot
var size = {
  x: 400 - margin.left - margin.right,
  y: 400 - margin.top - margin.bottom,
};

// Scatter Plot
var scatter_svg = d3
  .select("#scatter")
  .append("svg")
  .attr("width", size.x + margin.left + margin.right)
  .attr("height", size.y + margin.top + margin.bottom)
  .append("g")
  .attr("transform", "translate(" + margin.left + "," + margin.top +
    ")");

// append the svg object to the body of the page
var contour_svg = d3
  .select("#chart")
  .append("svg")
  .attr("width", size.x + margin.left + margin.right)
  .attr("height", size.y + margin.top + margin.bottom)
  .append("g")
  .attr("transform", "translate(" + margin.left + "," + margin.top +
    ")");

function render_graph(fname) {
  /////////////////////////////////////////////////////////////////////////
  // read data ////////////////////////////////////////////////////////////
  var fileNames = [fname];
  var filePaths = fileNames.map((fileName) => "resources/" +
  fileName);

  var header = null;

  const promises = filePaths.map((filePath) =>
    fetch(filePath)
    .then((response) => response.text())
    .then((data) => {
      let lines = data.trim()
        .split("\n");
      header = lines.slice(0, 1);
      lines = lines.slice(1)
        .map((line) => line.split(
        ",")); // slice(1) to skip the header
      lines = lines.map((line) => {
        return line.map((point) => parseFloat(point));
      });
      return lines;
    })
    .catch((error) =>
      console.error(`Error reading ${filePath}:`, error)
    )
  );

  Promise.all(promises)
    .then((results) => {
      // we can log the header here, how to make it into a legend?
      // TODO: add legend
      console.log(header);

      // parse the array returned by the file reader
      // results has shape [ [Array(5),Array(5),...], [Array(5),Array(5),...], ] as it contains data from ALL parsed files

      // for now, only use one file (likely want to make this a function later):
      results = results[0];

      /////////////////////////////////////////////////////////////////////////
      // Massage Data /////////////////////////////////////////////////////////
      var grid_2d = results.map((line) => line.slice(0, 2));
      // console.log("grid_2d:");
      // console.log(grid_2d);

      var probabilities = [];
      for (i = 2; i < results[0].length; i++) {
        probabilities.push(results.map((line) => line[i]));
      }
      // console.log("probabilities:");
      // console.log(probabilities);
      const num_classes = probabilities.length;

      /////////////////////////////////////////////////////////////////////////
      // Scaling functions ////////////////////////////////////////////////////
      const extent_x = d3.extent(
        grid_2d.map(function(value, index) {
          return value[0];
        })
      );

      const extent_y = d3.extent(
        grid_2d.map(function(value, index) {
          return value[1];
        })
      );

      const scale_x = d3
        .scaleLinear()
        .domain([extent_x[0], extent_x[1]])
        .range([0, size.x]);

      const scale_y = d3
        .scaleLinear()
        .domain([extent_y[0], extent_y[1]])
        .range([size.y, 0]);

      /////////////////////////////////////////////////////////////////////////
      // clear canvas /////////////////////////////////////////////////////////
      document.querySelectorAll(" svg > g > * ")
        .forEach((e) => e.remove());

      /////////////////////////////////////////////////////////////////////////
      // Add axis /////////////////////////////////////////////////////////////
      contour_svg
        .append("g")
        .attr("transform", "translate(0," + size.y + ")")
        .call(d3.axisBottom(scale_x));

      contour_svg
        .append("g")
        .call(d3.axisLeft(scale_y));

      /////////////////////////////////////////////////////////////////////////
      // Contour generation parameter /////////////////////////////////////////
      const thresholds = 15;
      // thresholds = [2, 3, 4, 5, 6, 7, 8, 9, 10];
      const bandwidth = 55;
      // red, blue, green, orange, pink, lightblue
      const colorCodes = ["#e31111", "#1153e3", "#11e32f", "#e39a11",
        "#d311e3", "#1172e3"
      ];

      const stroke_width = {
        min: 1,
        max: 3
      };

      const stroke_transparency = {
        min: 0.1,
        max: 1.0
      };

      const fill_transparency = {
        min: 0.05,
        max: 0.3
      };

      /////////////////////////////////////////////////////////////////////////
      // Contours data generation /////////////////////////////////////////////
      contour_svg
        .append("g")
        .attr("id", "contour_group")
        .attr("fill", "none")
        .attr("stroke-linejoin", "round");

      let allContours = []; // array of all contours, is not used in plot!
      
      for (j = 0; j < num_classes; j++) {
        let contours = d3.contourDensity()
          .x((d) => scale_x(d[0]))
          .y((d) => scale_y(d[1]))
          .weight(function(d, i) {
            return probabilities[j][i];
          })
          .bandwidth(bandwidth)
          .thresholds(thresholds)
          (grid_2d);

        const projection = d3
          .geoIdentity()
          .fitSize([size.x, size.y], contours[0]);
        const path = d3.geoPath()
          .projection(projection);

        contour_svg.select("#contour_group")
          .selectAll("path.class" + j)
          .data(contours)
          .enter()
          .append("path")
          // .attr("mix-blend-mode", "multiply") not yet working, currently working with stylesheet
          .attr("d", path)
          .attr("data-prob", (d) => d.value)
          .attr("class", "class" + j + " contours")

        allContours = allContours.concat(contours);
      }

      /////////////////////////////////////////////////////////////////////////
      // Sort contours by values //////////////////////////////////////////////
      const dom_contours = d3.selectAll(".contours");
      dom_sort("ascending", dom_contours);

      /////////////////////////////////////////////////////////////////////////
      // Prepare contour plot attributes //////////////////////////////////////
      const scale_by_threshold = function(min, max) { // returns a scaling function within the domain of
        const contour_thresh_extent = d3.extent(      // thresholds and in the specified min/max range
          allContours.map((d) => d.value)
          );

        return d3
          .scaleLinear()
          .domain([contour_thresh_extent[0], contour_thresh_extent[1]])
          .range([min, max])
        };

      const scale_stroke_width = scale_by_threshold(stroke_width.min, stroke_width.max);
      const scale_stroke_transparency = scale_by_threshold(stroke_transparency.min, stroke_transparency.max);
      const scale_transparency = scale_by_threshold(fill_transparency.min, fill_transparency.max);

      /////////////////////////////////////////////////////////////////////////
      // Set contour plot attributes //////////////////////////////////////////
      dom_contours
        .attr("stroke-width", d => scale_stroke_width(d.value));
      
      for ( i=0; i < num_classes; i++ ){
        d3.selectAll(".contours.class"+i)
          .attr("fill", d => prob(colorCodes[i], scale_transparency(d.value)))
          .attr("stroke", d => prob(colorCodes[i], scale_stroke_transparency(d.value)))
      }

      /////////////////////////////////////////////////////////////////////////
      // Scatter plot /////////////////////////////////////////////////////////
      scatter_svg
        .append("g")
        .attr("transform", "translate(0," + size.y + ")")
        .call(d3.axisBottom(scale_x));

      scatter_svg.append("g")
        .call(d3.axisLeft(scale_y));

      scatter_svg
        .selectAll("circle")
        .data(grid_2d)
        .enter()
        .append("circle")
        .attr("r", 1)
        .attr("fill", function(d, i) {
          return prob("#e31111", probabilities[2][i]);
        })
        .attr("cx", function(d, i) {
          return scale_x(d[0]);
        })
        .attr("cy", function(d, i) {
          return scale_y(d[1]);
        });
    
      
      /////////////////////////////////////////////////////////////////////////
      // END //////////////////////////////////////////////////////////////////

    }); // end of promises
} // end of render_graph()

updateDataset();
    </script>
  </body>
</html>
