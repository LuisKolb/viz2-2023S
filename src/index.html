<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>D3.js Contour Plot Example</title>
    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="https://d3js.org/d3-contour.v1.min.js"></script>
    <style>
      #tooltip {
        color: white;
        visibility: hidden;
        z-index: 9999;
        background: rgba(0, 0, 0, 0.5);
        position: absolute;
        border-radius: 25px;
        padding: 10px;
      }
    </style>
    <!-- <link rel="stylesheet" href="style.css"> -->
  </head>
  <body>
    <h1>D3.js Contour Plot Example</h1>

    <label for="dataset_selector">select a dataset</label>
    <select name="dataset" id="dataset_selector" onchange="updateDataset()">
      <option value="iris/petal length (cm)_vs_petal width (cm).txt" selected>
        iris/petal length (cm)_vs_petal width (cm)
      </option>
      <option value="iris/sepal length (cm)_vs_petal length (cm).txt">
        iris/sepal length (cm)_vs_petal length (cm)
      </option>
      <option value="iris/sepal length (cm)_vs_petal width (cm).txt">
        iris/sepal length (cm)_vs_petal width (cm)
      </option>
      <option value="iris/sepal length (cm)_vs_sepal width (cm).txt">
        iris/sepal length (cm)_vs_sepal width (cm)
      </option>
      <option value="iris/sepal width (cm)_vs_petal length (cm).txt">
        iris/sepal width (cm)_vs_petal length (cm)
      </option>
      <option value="iris/sepal width (cm)_vs_petal width (cm).txt">
        iris/sepal width (cm)_vs_petal width (cm)
      </option>
    </select>

    <br>

    <label for="cutoff">minimum confidence:</label>
    <span>0.0</span>
    <input type="range" id="cutoff" min="0" value="0.3" max="0.9" step="0.3" list="cutoff_ticks" oninput="updateOptions()">
    <span>0.9</span>
    <datalist id="cutoff_ticks">
      <option>0.0</option>
      <option>0.3</option>
      <option>0.6</option>
      <option>0.9</option>
    </datalist>

    <br>

    <label for="threshold">contour threshold:</label>
    <span>5</span>
    <input type="range" id="threshold" min="5" value="10" max="30" step="5" list="threshold_ticks" oninput="updateOptions()">
    <span>30</span>
    <datalist id="threshold_ticks">
      <option>5</option>
      <option>10</option>
      <option>15</option>
      <option>20</option>
      <option>25</option>
      <option>30</option>
    </datalist>
  
    <div class="optionSelected"></div>

    <div id="chart"></div>
    <div id="tooltip"></div>

    <script>
/////////////////////////////////////////////////////////////////////////
// Helper functions /////////////////////////////////////////////////////

// Renders the whole graph with new dataset
function updateDataset() {
  render_graph();
}

function updateOptions() {
  render_graph();
}

// Returns the alpha part of a hex code given the tranparency
function hexAlpha(transparency) {
  return Math.round((transparency * 255) / 100)
    .toString(16)
    .padStart(2, "0");
}

// returns a hexcode with alpha channel 
function prob(hexCode, propability) {
  return hexCode + hexAlpha(100.0 * propability);
}

function findClosest (x, arr) {
  var indexArr = arr.map(function(k) { return Math.abs(k - x) })
  var min = Math.min.apply(Math, indexArr)
  return indexArr.indexOf(min)
}

function getProbsFromMousePos(node, arr, scale_x, scale_y) {
  let mc = d3.mouse(node)

  let results_x = arr.map((v,i) => {return v[0]})
  let closest_x_idx = findClosest(scale_x.invert(mc[0]), results_x)

  let results_y = arr.map((v,i) => {return (results_x[closest_x_idx] == v[0]) ? v[1] : null})
  let closest_y_idx = findClosest(scale_y.invert(mc[1]), results_y)

  // TODO: colorcode?
  return arr[closest_x_idx,closest_y_idx].slice(2).map((num) => num.toFixed(2))
} 

/////////////////////////////////////////////////////////////////////////
// Prepare Canvas ///////////////////////////////////////////////////////

// set the dimensions and margins of the graph
var margin = {
  top: 50,
  right: 80,
  bottom: 80,
  left: 90
};

// size of the plot
var size = {
  x: 800 - margin.left - margin.right,
  y: 800 - margin.top - margin.bottom,
};

const filter_defs = 
'<filter id="glow"><fegaussianblur class="blur" result="coloredBlur" stddeviation="4"></fegaussianblur><femerge><femergenode in="coloredBlur"></femergenode><femergenode in="coloredBlur"></femergenode><femergenode in="coloredBlur"></femergenode><femergenode in="SourceGraphic"></femergenode></femerge></filter>';



// append the svg object to the body of the page
var contour_svg = d3
  .select("#chart")
  .append("svg")
  .attr("width", size.x + margin.left + margin.right)
  .attr("height", size.y + margin.top + margin.bottom)
  .append("g")
  .attr("transform", "translate(" + margin.left + "," + margin.top +
    ")");


function render_graph() {
  /////////////////////////////////////////////////////////////////////////
  // read options /////////////////////////////////////////////////////////
  var cutoff = document.getElementById("cutoff").value
  var threshold = document.getElementById("threshold").value


  /////////////////////////////////////////////////////////////////////////
  // read data ////////////////////////////////////////////////////////////
  var fname = document.getElementById("dataset_selector").value;
  var fileNames = [fname];
  var filePaths = fileNames.map((fileName) => "resources/" +
  fileName);

  var header = null;

  const promises = filePaths.map((filePath) =>
    fetch(filePath)
    .then((response) => response.text())
    .then((data) => {
      let lines = data.trim()
        .split("\n");
      header = lines.slice(0, 1);
      lines = lines.slice(1)
        .map((line) => line.split(
        ",")); // slice(1) to skip the header
      lines = lines.map((line) => {
        return line.map((point) => parseFloat(point));
      });
      
      lines = lines.map((line) => {
        return line.map((point, idx) => (((idx > 1) && (cutoff > point)) ? 0.0 : point))
      })
      return lines;
    })
    .catch((error) =>
      console.error(`Error reading ${filePath}:`, error)
    )
  );

  Promise.all(promises)
    .then((results) => {
      // cast line to string, remove next lines, split them into an array, uppercase first letters
      header = header.toString().replace(/(\r\n|\n|\r)/gm, "").split(","); 
      header.forEach((d, i) => header[i] = d.charAt(0).toUpperCase() + d.slice(1));
      

      // parse the array returned by the file reader
      // results has shape [ [Array(5),Array(5),...], [Array(5),Array(5),...], ] as it contains data from ALL parsed files

      // for now, only use one file (likely want to make this a function later):
      results = results[0];

      /////////////////////////////////////////////////////////////////////////
      // Massage Data /////////////////////////////////////////////////////////
      var grid_2d = results.map((line) => line.slice(0, 2));
      // console.log("grid_2d:");
      // console.log(grid_2d);

      var probabilities = [];
      for (i = 2; i < results[0].length; i++) {
        probabilities.push(results.map((line) => line[i]));
      }
      // console.log(probabilities);
  

      // console.log("probabilities:");
      // console.log(probabilities);
      const num_classes = probabilities.length;

      /////////////////////////////////////////////////////////////////////////
      // Scaling functions ////////////////////////////////////////////////////
      const extent_p = d3.extent(
        probabilities.flat()
      );

      const extent_x = d3.extent(
        grid_2d.map(function(value, index) {
          return value[0];
        })
      );

      const extent_y = d3.extent(
        grid_2d.map(function(value, index) {
          return value[1];
        })
      );

      const scale_x = d3
        .scaleLinear()
        .domain([extent_x[0], extent_x[1]])
        .range([0, size.x]);

      const scale_y = d3
        .scaleLinear()
        .domain([extent_y[0], extent_y[1]])
        .range([size.y, 0]);

      /////////////////////////////////////////////////////////////////////////
      // clear canvas /////////////////////////////////////////////////////////
      document.querySelectorAll(" svg > g > * ")
        .forEach((e) => e.remove());

      /////////////////////////////////////////////////////////////////////////
      // Add axis /////////////////////////////////////////////////////////////
      contour_svg
        .append("g")
        .attr("transform", "translate(0," + size.y + ")")
        .call(d3.axisBottom(scale_x));

      contour_svg
        .append("g")
        .call(d3.axisLeft(scale_y));

      /////////////////////////////////////////////////////////////////////////
      // Axis labels //////////////////////////////////////////////////////////
      contour_svg.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "end")
        .attr("x", size.x)
        .attr("y", size.y + 40)
        .text(header[0]);

      contour_svg.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "end")
        .attr("y", -40)
        .attr("dy", ".75em")
        .attr("transform", "rotate(-90)")
        .text(header[1]);

      /////////////////////////////////////////////////////////////////////////
      // Legend ///////////////////////////////////////////////////////////////
      // red, blue, green, orange, pink, lightblue
      const colorCodes = ["#e31111", "#1153e3", "#11e32f", "#e39a11",
        "#d311e3", "#1172e3"
      ];
      const legend_labels = header.slice(2);
      contour_svg.selectAll("legends_dots")
        .data(legend_labels)
        .enter()
        .append("circle")
          .attr("cx", size.x)
          .attr("cy", (d,i)=> 100 + i * 25)
          .attr("r", 7)
          .style("fill", (d, i) => colorCodes[i]);

      contour_svg.selectAll("legend_labels")
        .data(legend_labels)
        .enter()
        .append("text")
          .attr("x", size.x + 10)
          .attr("y", (d, i) => 100 + i * 25)
          .style("fill", "black")
          .text((d) => d)
          .attr("text-anchor", "left")
          .style("alignment-baseline", "middle");

      /////////////////////////////////////////////////////////////////////////
      // Contour generation parameter /////////////////////////////////////////
      let thresholds = threshold;
      // thresholds can be added as array, but they have to be insanely small, for whatever reason...
      // thresholds = [0.00001, 0.0001, 0.0004, 0.0008, 0.001, 0.005, 0.008];

      const bandwidth = 55;

      const stroke_width = {
        min: 1.5,
        max: 4.5
      };

      const stroke_transparency = {
        min: 0.1,
        max: 1.0
      };

      const render_halos = false;

      const halo_width = {
        min: 10,
        max: 10
      };

      const halo_color = "#ffffffD9"

      const fill_transparency = {
        min: 0.1,
        max: 0.5
      };

      const dash_array = "0"; // for dashes set to e.g. "5, 10, 5" for solids set to "0"

      const order_contours_by_threshold = true;

      /////////////////////////////////////////////////////////////////////////
      // Contours data generation /////////////////////////////////////////////
      var contour_group = contour_svg
        .append("g")
        .attr("id", "contour_group")
        .attr("fill", "none")
        .attr("stroke-linejoin", "round");

      let allContours = []; // array of all contours, is not used in plot!
            
      let filter = d3.selectAll("#contour_group").append("defs")
        .append("filter")
          .attr("id", "glow");

        filter.append("feGaussianBlur")
          .attr("class", "blur")
          .attr("result", "coloredBlur")
          .attr("stdDeviation", "4");

        filter.append("feMerge")
          .selectAll("feMergeNode")
          .data(["coloredBlur", "coloredBlur", "coloredBlur", "SourceGraphic"])
          .enter()
          .append("feMergeNode")
          .attr("in", d => d);

      
      for (j = 0; j < num_classes; j++) {
        let contours = d3.contourDensity()
          .size([size.x, size.y])
          .x((d) => scale_x(d[0]))
          .y((d) => scale_y(d[1]))
          .weight(function(d, i) {
            return probabilities[j][i];
          })
          .bandwidth(bandwidth)
          .thresholds(thresholds)
          (grid_2d);
        
        const projection = d3
          .geoIdentity()
          .fitSize([size.x, size.y], contours[0]);
        const path = d3.geoPath()
          .projection(projection);
        
        var tooltip = d3.select("#tooltip")
        
        // add contours to svg
        contour_svg.select("#contour_group")
          .selectAll("path.class" + j)
          .data(contours)
          .enter()
          .append("path")
          .attr("d", path)
          .attr("data-prob", (d,idx) => {return contours[idx].value}) // TODO: equivalent to d.value, but this is NOT what we want! (is the threshold, not the probability)
          .attr("class", "class" + j + " contours")
          .on("mouseover", (d,idx) => {
            tooltip.text(getProbsFromMousePos(contour_group.node(), results, scale_x, scale_y))
              .style("visibility", "visible")
          })
          .on("mousemove", () => {
            tooltip.text(getProbsFromMousePos(contour_group.node(), results, scale_x, scale_y))
              .style("top", (d3.event.pageY-10)+"px")
              .style("left",(d3.event.pageX+10)+"px")
          })
          .on("mouseout", () => {return tooltip.style("visibility", "hidden");})
          
        
        if(render_halos){
          contour_svg.select("#contour_group")
            .selectAll("path.class" + j + " halos")
            .data(contours)
            .enter()
            .append("path")
            .attr("d", path)
            .attr("data-prob", (d) => d.value)
            .attr("stroke-width", halo_width.max)
            .attr("stroke", halo_color)
            .attr("style", "filter: url(#glow)")
            .attr("class", "class" + j + " halos")
        }

        allContours = allContours.concat(contours);
      }

      /////////////////////////////////////////////////////////////////////////
      // Sort contours by values //////////////////////////////////////////////
      
      const dom_contours_halos = d3.selectAll(".contours,.halos");      
      const dom_contours = d3.selectAll(".contours");

      // orders contours correctly, but not completely correctly with halos
      if(order_contours_by_threshold){
        d3.selectAll(".contours,.halos").each(function(a, b) {
          if(this.getAttribute("class").includes("contours")){
            this.parentNode.appendChild(this);
          }
        });

        d3.selectAll(".contours,.halos").sort((a, b) => {
          const probA = a.value;
          const probB = b.value;
          return probA - probB;
        });
      }
      
      /* Sorts halos and contours correctly, but I don't get the sorted array inside the DOM ... :/
      let sort_helper = Array.from(dom_contours_halos["_groups"][0]);
      
      console.log(sort_helper);
      
      sort_helper.sort((a, b) => {
        const valueA = a.getAttribute("data-prob");
        const valueB = b.getAttribute("data-prob");
        if(valueA != valueB){
          return valueA - valueB;  
        }
        const classA = a.getAttribute("class");
        const classB = b.getAttribute("class");
        return -classA.localeCompare(classB); // does a lexical compare between e.g. "class1 contours" and "class0 halos"
      });

      console.log(sort_helper);
      */

      /////////////////////////////////////////////////////////////////////////
      // Prepare contour plot attributes //////////////////////////////////////
      const scale_by_threshold = function(min, max) { // returns a scaling function within the domain of
        const contour_thresh_extent = d3.extent(      // thresholds and in the specified min/max range
          allContours.map((d) => d.value)
          );

        return d3
          .scaleLinear()
          .domain([contour_thresh_extent[0], contour_thresh_extent[1]])
          .range([min, max])
        };

      const scale_stroke_width = scale_by_threshold(stroke_width.min, stroke_width.max);
      const scale_stroke_transparency = scale_by_threshold(stroke_transparency.min, stroke_transparency.max);
      const scale_transparency = scale_by_threshold(fill_transparency.min, fill_transparency.max);

      /////////////////////////////////////////////////////////////////////////
      // Set contour plot attributes //////////////////////////////////////////
      dom_contours
        .attr("stroke-width", d => scale_stroke_width(d.value))
        .attr("stroke-dasharray", dash_array)
        .attr("style", "mix-blend-mode: normal;");

      
      for ( i=0; i < num_classes; i++ ){
        d3.selectAll(".contours.class"+i)
          .attr("fill", d => prob(colorCodes[i], scale_transparency(d.value)))
          .attr("stroke", d => prob(colorCodes[i], scale_stroke_transparency(d.value)))
      }

      /////////////////////////////////////////////////////////////////////////
      // END //////////////////////////////////////////////////////////////////
    }); // end of promises
} // end of render_graph()

updateDataset();

    </script>
  </body>
</html>
